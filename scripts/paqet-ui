#!/usr/bin/env bash
set -euo pipefail

# Ensure whiptail runs on a real TTY (important when launched via `curl | bash`).
if [[ ! -t 0 || ! -t 1 || ! -t 2 ]]; then
  if [[ -r /dev/tty && -w /dev/tty ]]; then
    exec </dev/tty >/dev/tty 2>/dev/tty
  else
    echo "No interactive TTY available. Run: sudo paqet-ui" >&2
    exit 1
  fi
fi

# Fix for unknown TERM values (wezterm/xterm-kitty/etc.) when terminfo isn't installed.
# If termcap init fails, fall back to a widely-supported TERM.
if command -v tput >/dev/null 2>&1; then
  if ! tput sgr0 >/dev/null 2>&1; then
    export TERM=xterm-256color
    tput sgr0 >/dev/null 2>&1 || export TERM=xterm
  fi
fi

# Make sure the terminal isn't stuck in a weird mode (can break arrow keys).
stty sane >/dev/null 2>&1 || true
trap 'stty sane >/dev/null 2>&1 || true' EXIT

APP="paqet"
BIN="/usr/local/bin/paqet"

CONFIG_DIR="/etc/paqet"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"

LIB_DIR="/usr/local/lib/paqet"
IPTABLES_SH="${LIB_DIR}/paqet-iptables.sh"
IPTABLES_SYSTEMD_SH="${LIB_DIR}/paqet-systemd-iptables.sh"

SERVICE_NAME="paqet"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"

SYSCTL_CONF="/etc/sysctl.d/99-paqet.conf"

WATCHDOG_SCRIPT="/usr/local/bin/paqet-watchdog"
WATCHDOG_SERVICE_FILE="/etc/systemd/system/paqet-watchdog.service"
WATCHDOG_TIMER_FILE="/etc/systemd/system/paqet-watchdog.timer"

# rand_alnum prints a random alphanumeric string of length N (default 24).
rand_alnum() {
  local n="${1:-24}"
  if [[ -r /dev/urandom ]]; then
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "${n}"
    return 0
  fi
  # Fallback (should be rare).
  date +%s%N | tr -dc '0-9' | head -c "${n}"
}

# yaml_quote returns a safely single-quoted YAML scalar.
yaml_quote() {
  local s="${1-}"
  s="${s//$'\r'/}"
  s="${s//$'\n'/}"
  s="${s//\'/\'\'}"
  printf "'%s'" "${s}"
}

# Tunnel defaults (high-throughput). These are embedded in generated configs.
KCP_MODE="fast2"
KCP_MTU="1350"
PCAP_SNAPLEN="65535"
PCAP_PROMISC="false"
PCAP_IMMEDIATE="true"
PCAP_TIMEOUT_MS="0"

DSCP_DEFAULT="0"

DEBUG_PPROF_DEFAULT="127.0.0.1:6060"

# Client raw TCP port (local). We pick a stable port below the OS ephemeral range
# to reduce collisions with normal outbound connections and to allow iptables rules
# (RST-drop / NOTRACK) to be applied reliably by systemd helper scripts.
CLIENT_RAW_PORT_DEFAULT="20000"

pick_client_conn() {
  # Choose a reasonable default number of parallel KCP sessions for higher throughput.
  # More connections = more CPU and more parallelism.
  local n
  n="$(getconf _NPROCESSORS_ONLN 2>/dev/null || nproc 2>/dev/null || echo 1)"
  if ! [[ "${n}" =~ ^[0-9]+$ ]]; then
    n=1
  fi
  if (( n <= 2 )); then
    echo 1
  elif (( n <= 4 )); then
    echo 2
  elif (( n <= 8 )); then
    echo 4
  else
    # For 16c+ boxes, 8 parallel sessions is a good baseline.
    echo 8
  fi
}

pick_client_raw_port() {
  # Choose a port that is not LISTENing locally (best-effort) and stays below common ephemeral ranges.
  local p
  p="${CLIENT_RAW_PORT_DEFAULT}"
  while (( p < 30000 )); do
    if ! is_tcp_port_listening "${p}"; then
      printf "%s" "${p}"
      return 0
    fi
    p=$((p+1))
  done
  # Fallback: still return default (iptables helper may skip if conflicts are real).
  printf "%s" "${CLIENT_RAW_PORT_DEFAULT}"
  return 0
}

pick_client_raw_port_range() {
  # Pick a base port such that [base..base+conn-1] is free of LISTEN sockets.
  local conn="${1:-1}"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi

  local base end p
  base="${CLIENT_RAW_PORT_DEFAULT}"
  while (( base < 30000 )); do
    end=$(( base + conn - 1 ))
    if (( end > 65535 )); then
      break
    fi
    local ok="1"
    for ((p=base; p<=end; p++)); do
      if is_tcp_port_listening "${p}"; then
        ok="0"
        break
      fi
    done
    if [[ "${ok}" == "1" ]]; then
      printf "%s" "${base}"
      return 0
    fi
    base=$((base+1))
  done

  printf "%s" "${CLIENT_RAW_PORT_DEFAULT}"
  return 0
}

detect_mem_total_mb() {
  local kb
  kb="$(awk '/^MemTotal:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
  if [[ "${kb}" =~ ^[0-9]+$ ]] && (( kb > 0 )); then
    echo $(( kb / 1024 ))
    return 0
  fi
  echo 0
  return 0
}

pick_kcp_window() {
  # Pick a window size that is large enough for throughput but avoids OOM on smaller boxes.
  # Window applies per KCP session; total memory scales with `transport.conn`.
  local conn="${1:-1}"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi
  local mem
  mem="$(detect_mem_total_mb)"

  local wnd
  if (( mem > 0 && mem < 2048 )); then
    wnd=2048
  elif (( mem > 0 && mem < 4096 )); then
    wnd=4096
  elif (( mem > 0 && mem < 8192 )); then
    wnd=8192
  else
    wnd=16384
  fi

  # If we run many sessions, cap per-session window to keep total memory bounded.
  if (( conn >= 16 && wnd > 8192 )); then
    wnd=8192
  fi
  if (( conn >= 32 && wnd > 4096 )); then
    wnd=4096
  fi
  echo "${wnd}"
}

pick_smuxbuf() {
  local mem
  mem="$(detect_mem_total_mb)"
  if (( mem > 0 && mem < 2048 )); then
    echo $(( 4 * 1024 * 1024 ))
  elif (( mem > 0 && mem < 4096 )); then
    echo $(( 8 * 1024 * 1024 ))
  else
    echo $(( 16 * 1024 * 1024 ))
  fi
}

pick_streambuf() {
  # Per-stream buffer. Keep conservative to avoid memory spikes with many streams.
  local mem
  mem="$(detect_mem_total_mb)"
  if (( mem > 0 && mem < 2048 )); then
    echo $(( 256 * 1024 ))
  elif (( mem > 0 && mem < 4096 )); then
    echo $(( 512 * 1024 ))
  else
    echo $(( 1024 * 1024 ))
  fi
}

adjust_conn_to_free_server_port_range() {
  # Reduce conn until [base..base+conn-1] is free of LISTEN sockets.
  local base="${1:-9999}"
  local conn="${2:-1}"
  if ! [[ "${base}" =~ ^[0-9]+$ ]] || (( base < 1 )); then
    base=9999
  fi
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi
  if (( conn > 256 )); then
    conn=256
  fi

  while (( conn > 1 )); do
    local end p ok="1"
    end=$(( base + conn - 1 ))
    if (( end > 65535 )); then
      conn=$((conn-1))
      continue
    fi
    for ((p=base; p<=end; p++)); do
      if is_tcp_port_listening "${p}"; then
        ok="0"
        break
      fi
    done
    if [[ "${ok}" == "1" ]]; then
      echo "${conn}"
      return 0
    fi
    conn=$((conn-1))
  done
  echo 1
}

need_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    exec sudo -E "$0" "$@"
  fi
}

need_cmd() { command -v "$1" >/dev/null 2>&1; }

ensure_deps() {
  local missing=()
  for c in whiptail ip ss iptables systemctl awk sed grep cut tr head tail curl; do
    need_cmd "$c" || missing+=("$c")
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Missing deps: ${missing[*]}" >&2
    echo "Run: sudo apt-get update && sudo apt-get install -y whiptail iproute2 iptables" >&2
    exit 1
  fi
  if [[ ! -x "${BIN}" ]]; then
    echo "Binary not found at ${BIN}. Run install.sh first." >&2
    exit 1
  fi
}

msg() { whiptail --title "${APP}" --msgbox "$1" 12 78; }

textbox() {
  # Safer than process substitution; works reliably across environments.
  local title="$1" height="${2:-22}" width="${3:-78}"
  local tmp
  tmp="$(mktemp)"
  cat >"${tmp}"
  whiptail --title "${title}" --scrolltext --textbox "${tmp}" "${height}" "${width}"
  rm -f "${tmp}"
}

input() {
  local title="$1" prompt="$2" def="${3:-}"
  local out
  out="$(whiptail --title "${title}" --inputbox "${prompt}" 12 78 "${def}" 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

password() {
  local title="$1" prompt="$2"
  local out
  out="$(whiptail --title "${title}" --passwordbox "${prompt}" 12 78 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

yesno() {
  local title="$1" prompt="$2"
  if whiptail --title "${title}" --yesno "${prompt}" 12 78; then
    return 0
  fi
  return 1
}

menu() {
  local title="$1" prompt="$2"
  shift 2
  whiptail --title "${title}" --menu "${prompt}" 18 78 10 "$@" 3>&1 1>&2 2>&3
}

ss_listen_tcp() {
  # Output TCP LISTEN sockets for a port (best-effort).
  local port="$1"
  ss -lntpH "sport = :${port}" 2>/dev/null || true
}

extract_pids_from_ss() {
  # Extract pid list from ss output.
  grep -oE 'pid=[0-9]+' | cut -d= -f2 | sort -u
}

is_tcp_port_listening() {
  local port="$1"
  local out
  out="$(ss_listen_tcp "${port}")"
  [[ -n "${out}" ]]
}

kill_port_pids() {
  local port="$1"
  local out pids
  out="$(ss_listen_tcp "${port}")"
  pids="$(printf "%s\n" "${out}" | extract_pids_from_ss || true)"
  if [[ -z "${pids}" ]]; then
    msg "نتونستم PID رو از ss پیدا کنم.\n\n${out}"
    return 1
  fi

  if ! yesno "${APP}" "این PIDها روی پورت ${port} گوش میدن:\n${pids}\n\nKill کنیم؟"; then
    return 1
  fi

  for pid in ${pids}; do
    kill -TERM "${pid}" >/dev/null 2>&1 || true
  done
  sleep 1
  for pid in ${pids}; do
    kill -KILL "${pid}" >/dev/null 2>&1 || true
  done
  return 0
}

ensure_tcp_port_free_or_prompt() {
  # Loops until port is free, or user cancels. Prints the chosen port.
  local port="$1"
  local purpose="$2"

  while is_tcp_port_listening "${port}"; do
    local out choice
    out="$(ss_listen_tcp "${port}")"
    choice="$(menu "${APP}" "پورت ${port} برای ${purpose} مشغول است.\n\n${out}\n\nچه کار کنیم؟" \
      "1" "Stop paqet service (اگر خودش گرفته)" \
      "2" "Kill process(es) on this port" \
      "3" "Choose a different port" \
      "0" "Cancel")" || return 1

    case "${choice}" in
      1)
        systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
        ;;
      2)
        kill_port_pids "${port}" || true
        ;;
      3)
        port="$(input "${APP}" "پورت جدید برای ${purpose}:" "${port}")" || return 1
        ;;
      0)
        return 1
        ;;
    esac
  done

  printf "%s" "${port}"
}

ensure_tcp_port_free_or_prompt_simple() {
  # Same as ensure_tcp_port_free_or_prompt, but does NOT offer changing ports.
  # This keeps the "simple setup" flow portless for the user.
  local port="$1"
  local purpose="$2"

  while is_tcp_port_listening "${port}"; do
    local out choice
    out="$(ss_listen_tcp "${port}")"
    choice="$(menu "${APP}" "پورت ${port} برای ${purpose} مشغول است.\n\n${out}\n\nچه کار کنیم؟" \
      "1" "Stop paqet service (اگر خودش گرفته)" \
      "2" "Kill process(es) on this port" \
      "0" "Cancel")" || return 1

    case "${choice}" in
      1)
        systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
        ;;
      2)
        kill_port_pids "${port}" || true
        ;;
      0)
        return 1
        ;;
    esac
  done

  printf "%s" "${port}"
}

ensure_service_can_reconfigure() {
  # If service is active, ask user to stop or cancel.
  if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
    if yesno "${APP}" "سرویس ${SERVICE_NAME} الان فعاله. برای ستاپ جدید باید متوقف بشه.\n\nStop کنیم؟"; then
      systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
    else
      return 1
    fi
  fi
  return 0
}

detect_default_iface() {
  ip route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="dev") {print $(i+1); exit}}'
}

detect_local_ipv4() {
  local iface="$1"
  ip -4 -o addr show dev "${iface}" scope global 2>/dev/null | awk '{print $4}' | head -n1 | cut -d/ -f1
}

detect_gateway_ipv4() {
  ip -4 route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="via") {print $(i+1); exit}}'
}

detect_gateway_mac() {
  local gw="$1" iface="$2"
  ip neigh show "${gw}" dev "${iface}" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="lladdr") {print $(i+1); exit}}'
}

ensure_gateway_mac() {
  local gw="$1" iface="$2"
  local mac
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  ping -c 1 -W 1 "${gw}" >/dev/null 2>&1 || true
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  return 1
}

write_sysctl_defaults() {
  cat >"${SYSCTL_CONF}" <<'EOF'
# paqet baseline tuning (adjust per host/RAM/NIC)
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.core.rmem_default = 8388608
net.core.wmem_default = 8388608
net.core.netdev_max_backlog = 250000
EOF
  sysctl --system >/dev/null 2>&1 || true
}

install_watchdog() {
  # A lightweight guard to bring paqet back if it is stopped/failed by anything
  # (cron, operator mistake, transient OOM, etc.). It never restarts an active service.
  cat >"${WATCHDOG_SCRIPT}" <<'SH'
#!/usr/bin/env bash
set -euo pipefail

svc="paqet"

en="$(systemctl is-enabled "${svc}" 2>/dev/null || true)"
case "${en}" in
  disabled|masked) exit 0 ;;
esac

st="$(systemctl is-active "${svc}" 2>/dev/null || true)"
case "${st}" in
  active|activating|deactivating) exit 0 ;;
esac

logger -t paqet-watchdog "paqet state=${st}; reset-failed + restart"
systemctl reset-failed "${svc}" >/dev/null 2>&1 || true
systemctl restart "${svc}" >/dev/null 2>&1 || true
SH
  chmod 0755 "${WATCHDOG_SCRIPT}" || true

  cat >"${WATCHDOG_SERVICE_FILE}" <<'UNIT'
[Unit]
Description=Watchdog: keep paqet.service running
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/paqet-watchdog
UNIT

  cat >"${WATCHDOG_TIMER_FILE}" <<'TIMER'
[Unit]
Description=Run paqet watchdog periodically

[Timer]
OnBootSec=45s
OnUnitActiveSec=45s
AccuracySec=5s
Unit=paqet-watchdog.service

[Install]
WantedBy=timers.target
TIMER

  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl enable --now paqet-watchdog.timer >/dev/null 2>&1 || true
}

remove_watchdog() {
  systemctl disable --now paqet-watchdog.timer >/dev/null 2>&1 || true
  rm -f "${WATCHDOG_TIMER_FILE}" "${WATCHDOG_SERVICE_FILE}" "${WATCHDOG_SCRIPT}" || true
  systemctl daemon-reload >/dev/null 2>&1 || true
}

install_service() {
  mkdir -p "${CONFIG_DIR}" "${LIB_DIR}"

  if [[ ! -x "${IPTABLES_SH}" ]]; then
    msg "iptables helper not found at ${IPTABLES_SH}. Re-install scripts."
    return 1
  fi
  if [[ ! -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    msg "systemd iptables helper not found at ${IPTABLES_SYSTEMD_SH}. Re-install scripts."
    return 1
  fi

  cat >"${SERVICE_FILE}" <<EOF
[Unit]
Description=paqet tunnel
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStartPre=${IPTABLES_SYSTEMD_SH} apply ${CONFIG_FILE}
ExecStart=${BIN} run -c ${CONFIG_FILE}
ExecStopPost=${IPTABLES_SYSTEMD_SH} remove ${CONFIG_FILE}
Restart=on-failure
RestartSec=1
LimitNOFILE=1048576

# Hardening (keep compatible with raw sockets)
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${SERVICE_NAME}" >/dev/null 2>&1 || true
  install_watchdog
}

start_service() {
  systemctl restart "${SERVICE_NAME}"
}

status_screen() {
  local out
  out="$(SYSTEMD_COLORS=0 systemctl status "${SERVICE_NAME}" --no-pager --full --plain 2>&1 || true)"
  if [[ -z "${out}" ]]; then
    out="(empty output)\n\nTry: systemctl status ${SERVICE_NAME}"
  fi
  printf "%b\n" "${out}" | textbox "${APP} status" 22 78
}

redact_config() {
  if [[ -f "${CONFIG_FILE}" ]]; then
    sed -E \
      -e 's/^([[:space:]]*key:[[:space:]]*).*/\1"***REDACTED***"/' \
      -e 's/^([[:space:]]*password:[[:space:]]*).*/\1"***REDACTED***"/' \
      "${CONFIG_FILE}"
  else
    echo "MISSING: ${CONFIG_FILE}"
  fi
}

detect_cfg_iface() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    return 0
  fi
  awk '
    BEGIN { in_net=0 }
    /^[[:space:]]*network:[[:space:]]*$/ { in_net=1; next }
    in_net && /^[^[:space:]][^:]*:/ { in_net=0 }
    in_net && /^[[:space:]]*interface:[[:space:]]*/ {
      line=$0
      sub(/^[[:space:]]*interface:[[:space:]]*/, "", line)
      sub(/[[:space:]]+#.*/, "", line)
      gsub(/^"/, "", line); gsub(/"$/, "", line)
      print line
      exit
    }
  ' "${CONFIG_FILE}" 2>/dev/null || true
}

detect_cfg_pprof() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    return 0
  fi
  awk '
    BEGIN { in_dbg=0 }
    /^[[:space:]]*debug:[[:space:]]*$/ { in_dbg=1; next }
    in_dbg && /^[^[:space:]][^:]*:/ { in_dbg=0 }
    in_dbg && /^[[:space:]]*pprof:[[:space:]]*/ {
      line=$0
      sub(/^[[:space:]]*pprof:[[:space:]]*/, "", line)
      sub(/[[:space:]]+#.*/, "", line)
      gsub(/^"/, "", line); gsub(/"$/, "", line)
      print line
      exit
    }
  ' "${CONFIG_FILE}" 2>/dev/null || true
}

detect_transport_conn() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    return 0
  fi
  awk '
    BEGIN { in_transport=0 }
    /^[[:space:]]*transport:[[:space:]]*$/ { in_transport=1; next }
    in_transport && /^[^[:space:]][^:]*:/ { in_transport=0 }
    in_transport && /^[[:space:]]*conn:[[:space:]]*/ {
      line=$0
      sub(/^[[:space:]]*conn:[[:space:]]*/, "", line)
      sub(/[[:space:]]+#.*/, "", line)
      gsub(/[^0-9]/, "", line)
      print line
      exit
    }
  ' "${CONFIG_FILE}" 2>/dev/null || true
}

set_log_level() {
  local level="$1"
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi
  local tmp
  tmp="$(mktemp)"
  awk -v lvl="${level}" '
    BEGIN { in_log=0 }
    /^[[:space:]]*log:[[:space:]]*$/ { in_log=1; print; next }
    in_log && /^[^[:space:]][^:]*:/ { in_log=0 }
    in_log && /^[[:space:]]*level:[[:space:]]*/ { print "  level: \"" lvl "\""; next }
    { print }
  ' "${CONFIG_FILE}" >"${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
  systemctl restart "${SERVICE_NAME}" || true
  return 0
}

set_snaplen() {
  local snaplen="$1"
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi
  # Best-effort: update any existing snaplen line. If absent, defaults apply in paqet.
  sed -i -E "s/^([[:space:]]*snaplen:)[[:space:]]*[0-9]+/\\1 ${snaplen}/" "${CONFIG_FILE}" || true
  chmod 600 "${CONFIG_FILE}" || true
  systemctl restart "${SERVICE_NAME}" || true
  return 0
}

set_dscp() {
  local dscp="$1"
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi
  if ! [[ "${dscp}" =~ ^[0-9]+$ ]] || (( dscp < 0 || dscp > 63 )); then
    msg "DSCP باید عدد بین 0 تا 63 باشد."
    return 1
  fi

  local tmp
  tmp="$(mktemp)"
  awk -v dscp="${dscp}" '
    BEGIN { in_net=0; saw_net=0; wrote=0 }
    /^[[:space:]]*network:[[:space:]]*$/ {
      in_net=1
      saw_net=1
      wrote=0
      print
      next
    }
    in_net && /^[^[:space:]][^:]*:/ {
      if (wrote == 0) { print "  dscp: " dscp; wrote=1 }
      in_net=0
      # fallthrough to print this top-level line
    }
    in_net && /^[[:space:]]*dscp:[[:space:]]*/ {
      if (wrote == 0) { print "  dscp: " dscp; wrote=1 }
      next
    }
    { print }
    END {
      if (in_net == 1 && wrote == 0) {
        print "  dscp: " dscp
      }
      if (saw_net == 0) {
        # Should never happen (config always has a network block), but keep file valid.
        print ""
        print "network:"
        print "  dscp: " dscp
      }
    }
  ' "${CONFIG_FILE}" >"${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
  systemctl restart "${SERVICE_NAME}" || true
  return 0
}

apply_kcp_tuning() {
  local mode="${1:-${KCP_MODE}}" wnd="${2:-}" smuxbuf="${3:-}" streambuf="${4:-}"
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi
  if ! [[ "${wnd}" =~ ^[0-9]+$ ]] || (( wnd < 1 || wnd > 65535 )); then
    msg "Window باید عدد بین 1 تا 65535 باشد."
    return 1
  fi
  if ! [[ "${smuxbuf}" =~ ^[0-9]+$ ]] || (( smuxbuf < 1024 )); then
    msg "smuxbuf باید >= 1024 باشد."
    return 1
  fi
  if ! [[ "${streambuf}" =~ ^[0-9]+$ ]] || (( streambuf < 1024 )); then
    msg "streambuf باید >= 1024 باشد."
    return 1
  fi

  local tmp
  tmp="$(mktemp)"
  awk -v mode="${mode}" -v wnd="${wnd}" -v smuxbuf="${smuxbuf}" -v streambuf="${streambuf}" '
    BEGIN {
      in_kcp=0; saw_kcp=0;
      kcp_indent=""; key_indent="";
      saw_mode=0; saw_rcv=0; saw_snd=0; saw_smux=0; saw_stream=0
    }
    /^[[:space:]]*kcp:[[:space:]]*$/ {
      saw_kcp=1
      in_kcp=1
      match($0, /^[[:space:]]*/)
      kcp_indent = substr($0, 1, RLENGTH)
      key_indent = kcp_indent "  "
      print
      next
    }
    {
      if (in_kcp == 1) {
        match($0, /^[[:space:]]*/)
        curr = RLENGTH
        if (curr <= length(kcp_indent) && $0 ~ /^[[:space:]]*[A-Za-z0-9_]+:/) {
          if (saw_mode == 0)   print key_indent "mode: \"" mode "\""
          if (saw_rcv == 0)    print key_indent "rcvwnd: " wnd
          if (saw_snd == 0)    print key_indent "sndwnd: " wnd
          if (saw_smux == 0)   print key_indent "smuxbuf: " smuxbuf
          if (saw_stream == 0) print key_indent "streambuf: " streambuf
          in_kcp = 0
        }
      }
    }
    in_kcp == 1 && /^[[:space:]]*mode:[[:space:]]*/     { print key_indent "mode: \"" mode "\""; saw_mode=1; next }
    in_kcp == 1 && /^[[:space:]]*rcvwnd:[[:space:]]*/   { print key_indent "rcvwnd: " wnd; saw_rcv=1; next }
    in_kcp == 1 && /^[[:space:]]*sndwnd:[[:space:]]*/   { print key_indent "sndwnd: " wnd; saw_snd=1; next }
    in_kcp == 1 && /^[[:space:]]*smuxbuf:[[:space:]]*/  { print key_indent "smuxbuf: " smuxbuf; saw_smux=1; next }
    in_kcp == 1 && /^[[:space:]]*streambuf:[[:space:]]*/{ print key_indent "streambuf: " streambuf; saw_stream=1; next }
    { print }
    END {
      if (in_kcp == 1) {
        if (saw_mode == 0)   print key_indent "mode: \"" mode "\""
        if (saw_rcv == 0)    print key_indent "rcvwnd: " wnd
        if (saw_snd == 0)    print key_indent "sndwnd: " wnd
        if (saw_smux == 0)   print key_indent "smuxbuf: " smuxbuf
        if (saw_stream == 0) print key_indent "streambuf: " streambuf
      }
    }
  ' "${CONFIG_FILE}" >"${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
  systemctl restart "${SERVICE_NAME}" || true
  return 0
}

retune_kcp_defaults() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi
  local conn wnd smuxbuf streambuf
  conn="$(detect_transport_conn || true)"
  if [[ -z "${conn}" ]]; then
    conn=1
  fi
  wnd="$(pick_kcp_window "${conn}")"
  smuxbuf="$(pick_smuxbuf)"
  streambuf="$(pick_streambuf)"

  apply_kcp_tuning "${KCP_MODE}" "${wnd}" "${smuxbuf}" "${streambuf}" || return 1
  msg "تنظیمات KCP اعمال شد:\n\nmode=${KCP_MODE}\nwnd=${wnd}\nsmuxbuf=${smuxbuf}\nstreambuf=${streambuf}"
  return 0
}

set_dscp_menu() {
  local choice
  choice="$(menu "${APP}" "DSCP (Traffic Class) روی بعضی شبکه‌ها باعث افت شدید پهنای‌باند می‌شود.\n\nکدام را می‌خواهی؟" \
    "0" "DSCP=0 (پیشنهادی برای throughput)" \
    "46" "DSCP=46 (EF - low latency, ممکنه سخت پلیس بشه)" \
    "C" "Custom (0-63)" \
    "B" "Back")" || return 0

  case "${choice}" in
    0|46)
      set_dscp "${choice}" || true
      ;;
    C)
      local v
      v="$(input "${APP}" "DSCP (0-63):" "0")" || return 0
      set_dscp "${v}" || true
      ;;
    B)
      return 0
      ;;
  esac
}

set_debug_endpoints() {
  local enable="$1" pprof="${2:-${DEBUG_PPROF_DEFAULT}}"
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}"
    return 1
  fi

  local diag="false"
  local pprof_line="\"\""
  if [[ "${enable}" == "true" ]]; then
    diag="true"
    pprof_line="\"${pprof}\""
  fi

  local tmp
  tmp="$(mktemp)"
  awk -v pprof="${pprof_line}" -v diag="${diag}" '
    # Ensure debug block is idempotent and unique.
    # Old UI versions inserted a duplicate "debug:" block (YAML parser rejects duplicate keys).
    BEGIN { in_dbg=0; skip_dbg=0; saw_dbg=0; wrote_pprof=0; wrote_diag=0 }
    /^[[:space:]]*debug:[[:space:]]*$/ {
      if (saw_dbg == 0) {
        saw_dbg=1
        in_dbg=1
        skip_dbg=0
        wrote_pprof=0
        wrote_diag=0
        print
        next
      }
      # Duplicate debug block: skip it entirely.
      in_dbg=0
      skip_dbg=1
      next
    }
    skip_dbg == 1 {
      # Exit skip mode when next top-level key starts.
      if ($0 ~ /^[^[:space:]][^:]*:/) {
        skip_dbg=0
        # fallthrough to process this line normally
      } else {
        next
      }
    }
    in_dbg == 1 && $0 ~ /^[^[:space:]][^:]*:/ {
      # Leaving debug block: ensure keys exist.
      if (wrote_pprof == 0) { print "  pprof: " pprof }
      if (wrote_diag == 0)  { print "  diag: " diag }
      in_dbg=0
      # fallthrough to process this top-level line
    }
    in_dbg == 1 && /^[[:space:]]*pprof:[[:space:]]*/ { print "  pprof: " pprof; wrote_pprof=1; next }
    in_dbg == 1 && /^[[:space:]]*diag:[[:space:]]*/  { print "  diag: " diag; wrote_diag=1; next }
    { print }
    END {
      if (in_dbg == 1) {
        if (wrote_pprof == 0) { print "  pprof: " pprof }
        if (wrote_diag == 0)  { print "  diag: " diag }
      }
      if (saw_dbg == 0) {
        print ""
        print "debug:"
        print "  pprof: " pprof
        print "  diag: " diag
      }
    }
  ' "${CONFIG_FILE}" >"${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
  systemctl restart "${SERVICE_NAME}" || true
  return 0
}

show_debug_status() {
  local pprof
  pprof="$(detect_cfg_pprof || true)"
  if [[ -z "${pprof}" ]]; then
    pprof="${DEBUG_PPROF_DEFAULT}"
  fi
  if ! curl -fsS "http://${pprof}/debug/paqet/text" 2>/dev/null | textbox "${APP} debug status" 22 78; then
    msg "به /debug/paqet/text دسترسی ندارم.\n\nاول از منو Debug رو فعال کن (pprof+diag) و دوباره تلاش کن.\n\npprof: ${pprof}"
  fi
}

live_monitor() {
  local iface pprof
  iface="$(detect_cfg_iface || true)"
  if [[ -z "${iface}" ]]; then
    iface="$(detect_default_iface || true)"
  fi
  pprof="$(detect_cfg_pprof || true)"
  if [[ -z "${pprof}" ]]; then
    pprof="${DEBUG_PPROF_DEFAULT}"
  fi

  if ! command -v python3 >/dev/null 2>&1; then
    msg "python3 نصب نیست.\n\nبرای مانیتور لحظه‌ای نصب کن:\n  sudo apt-get update && sudo apt-get install -y python3"
    return 1
  fi

  clear
  echo "paqet live monitor"
  echo "iface=${iface} pprof=${pprof}"
  echo "Press Ctrl+C to stop and return."
  echo

  IFACE="${iface}" PPROF="${pprof}" python3 - <<'PY'
import json, os, time, urllib.request, subprocess

iface=os.environ.get("IFACE") or "eth0"
pprof=os.environ.get("PPROF") or "127.0.0.1:6060"
url=f"http://{pprof}/debug/paqet/status"

def sh(cmd):
    return subprocess.check_output(cmd, shell=True, text=True).strip()

def rint(p):
    with open(p,"r") as f:
        return int(f.read().strip())

def tj():
    parts=open("/proc/stat","r").readline().split()[1:]
    return sum(int(x) for x in parts)

def pj(pid):
    s=open(f"/proc/{pid}/stat","r").read()
    i=s.rfind(")")
    rest=s[i+2:].split()
    return int(rest[11]) + int(rest[12])

def softdrop():
    d=0
    for line in open("/proc/net/softnet_stat","r"):
        c=line.split()
        if len(c)>1:
            d += int(c[1],16)
    return d

def get_status():
    try:
        with urllib.request.urlopen(url, timeout=0.5) as r:
            return json.load(r)
    except Exception:
        return None

cpu_n=os.cpu_count() or 1
try:
    pid_s = sh("pidof paqet | awk '{print $1}'")
    pid = int(pid_s) if pid_s else None
except Exception:
    pid = None

rxp=f"/sys/class/net/{iface}/statistics/rx_bytes"
txp=f"/sys/class/net/{iface}/statistics/tx_bytes"
rxd_p=f"/sys/class/net/{iface}/statistics/rx_dropped"
txd_p=f"/sys/class/net/{iface}/statistics/tx_dropped"

prev = {
    "t": time.time(),
    "rx": rint(rxp),
    "tx": rint(txp),
    "rxd": rint(rxd_p),
    "txd": rint(txd_p),
    "soft": softdrop(),
    "tj": tj(),
    "pj": pj(pid) if pid else 0,
    "appu": 0,
    "appd": 0,
    "rawu": 0,
    "rawd": 0,
}

st = get_status()
if st:
    prev["appu"] = int(st.get("tcp_up_bytes",0)) + int(st.get("udp_up_bytes",0))
    prev["appd"] = int(st.get("tcp_down_bytes",0)) + int(st.get("udp_down_bytes",0))
    prev["rawu"] = int(st.get("raw_up_bytes",0))
    prev["rawd"] = int(st.get("raw_down_bytes",0))

print("time  IF(rx/tx Mbps)  drops(rx/tx/soft)  paqetCPU%  app(up/down Mbps)  raw(up/down Mbps)  sessions streams guardDrops")

while True:
    time.sleep(1)
    now = time.time()
    dt = max(0.001, now - prev["t"])

    rx = rint(rxp); tx = rint(txp)
    rxd = rint(rxd_p); txd = rint(txd_p)
    soft = softdrop()

    rx_m = (rx - prev["rx"]) * 8 / dt / 1e6
    tx_m = (tx - prev["tx"]) * 8 / dt / 1e6

    cpu = 0.0
    if pid:
        n_tj = tj()
        n_pj = pj(pid)
        d_tj = n_tj - prev["tj"]
        d_pj = n_pj - prev["pj"]
        if d_tj > 0:
            cpu = (d_pj / d_tj) * 100.0 * cpu_n
        prev["tj"] = n_tj
        prev["pj"] = n_pj

    st = get_status()
    appu_m = appd_m = rawu_m = rawd_m = 0.0
    sessions = streams = guard_drops = 0
    if st:
        appu = int(st.get("tcp_up_bytes",0)) + int(st.get("udp_up_bytes",0))
        appd = int(st.get("tcp_down_bytes",0)) + int(st.get("udp_down_bytes",0))
        rawu = int(st.get("raw_up_bytes",0))
        rawd = int(st.get("raw_down_bytes",0))
        appu_m = (appu - prev["appu"]) * 8 / dt / 1e6
        appd_m = (appd - prev["appd"]) * 8 / dt / 1e6
        rawu_m = (rawu - prev["rawu"]) * 8 / dt / 1e6
        rawd_m = (rawd - prev["rawd"]) * 8 / dt / 1e6
        prev["appu"], prev["appd"], prev["rawu"], prev["rawd"] = appu, appd, rawu, rawd
        sessions = int(st.get("sessions",0))
        streams = int(st.get("streams",0))
        guard_drops = int(st.get("guard_drops",0))

    print(f"{time.strftime('%H:%M:%S')} {rx_m:8.1f}/{tx_m:8.1f}  {rxd-prev['rxd']}/{txd-prev['txd']}/{soft-prev['soft']:4}     {cpu:7.1f}     {appu_m:7.1f}/{appd_m:7.1f}    {rawu_m:7.1f}/{rawd_m:7.1f}  {sessions:>4} {streams:>6} {guard_drops}", flush=True)
    prev["t"], prev["rx"], prev["tx"], prev["rxd"], prev["txd"], prev["soft"] = now, rx, tx, rxd, txd, soft
PY

  stty sane >/dev/null 2>&1 || true
}

follow_journal() {
  clear
  echo "journalctl -u ${SERVICE_NAME} -f"
  echo "Press Ctrl+C to stop and return."
  echo
  journalctl -u "${SERVICE_NAME}" -f --no-pager || true
  stty sane >/dev/null 2>&1 || true
}

support_report() {
  local ts out iface pprof
  ts="$(date +%Y%m%d-%H%M%S)"
  out="/tmp/paqet-support-${ts}.txt"
  iface="$(detect_cfg_iface || true)"
  if [[ -z "${iface}" ]]; then
    iface="$(detect_default_iface || true)"
  fi
  pprof="$(detect_cfg_pprof || true)"
  if [[ -z "${pprof}" ]]; then
    pprof="${DEBUG_PPROF_DEFAULT}"
  fi

  {
    echo "=== HOST ==="
    hostname
    date -Is
    uname -a
    echo

    echo "=== RESOURCES ==="
    echo "-- CPU --"
    (command -v lscpu >/dev/null 2>&1 && lscpu) || true
    echo
    echo "-- MEM --"
    (command -v free >/dev/null 2>&1 && free -h) || true
    (command -v vmstat >/dev/null 2>&1 && vmstat -SM 1 3) || true
    echo
    echo "-- LIMITS --"
    ulimit -n || true
    echo

    echo "=== PAQET VERSION ==="
    "${BIN}" version 2>&1 || true
    echo

    echo "=== CONFIG (key/password redacted) ==="
    redact_config
    echo

    echo "=== SYSTEMD STATUS ==="
    systemctl status "${SERVICE_NAME}" --no-pager -l || true
    echo

    echo "=== JOURNAL (last 200) ==="
    journalctl -u "${SERVICE_NAME}" -n 200 --no-pager || true
    echo

    echo "=== LISTEN (TCP) ==="
    ss -lntpH 2>/dev/null || true
    echo

    echo "=== IPTABLES (relevant) ==="
    iptables -t raw -S 2>/dev/null | grep -E "NOTRACK" || true
    iptables -t mangle -S 2>/dev/null | grep -E "tcp-flags RST RST" || true
    echo

    echo "=== NET (iface=${iface}) ==="
    if [[ -n "${iface}" ]]; then
      ip -br addr show dev "${iface}" 2>/dev/null || true
      ip -s link show dev "${iface}" 2>/dev/null || true
    else
      ip -br addr 2>/dev/null || true
      ip -s link 2>/dev/null || true
    fi
    echo

    if command -v ethtool >/dev/null 2>&1 && [[ -n "${iface}" ]]; then
      echo "=== OFFLOADS (${iface}) ==="
      ethtool -k "${iface}" 2>/dev/null | egrep -i '(gro|lro|gso|tso|rx|tx|scatter|segmentation|udp)' || true
      echo
    fi

    echo "=== SYSCTL (relevant) ==="
    (sysctl net.core.rmem_max net.core.wmem_max net.core.rmem_default net.core.wmem_default net.core.netdev_max_backlog net.ipv4.ip_local_port_range net.netfilter.nf_conntrack_max 2>/dev/null) || true
    echo

    echo "=== KERNEL (oom / drops) ==="
    (dmesg -T 2>/dev/null | egrep -i 'out of memory|oom-kill|oom killer|softnet|nf_conntrack: table full' | tail -n 50) || true
    echo

    echo "=== DEBUG (/debug/paqet/text) ==="
    curl -fsS "http://${pprof}/debug/paqet/text" 2>/dev/null || echo "(debug endpoints not reachable)"
    echo
  } >"${out}" 2>&1 || true

  msg "گزارش ساخته شد:\n${out}\n\nبرای ارسال به من، این دستور رو بزن و خروجی رو کپی کن:\n\nsudo cat ${out}"
}

diagnostics_loop() {
  while true; do
    local choice
    choice="$(menu "${APP}" "Diagnostics / Debug:" \
      "1" "Generate support report (easy copy/paste)" \
      "2" "Show config (redacted)" \
      "3" "Show journal (last 200)" \
      "4" "Follow journal (Ctrl+C)" \
      "5" "Set log level (info/debug)" \
      "6" "Enable debug endpoints (pprof+diag)" \
      "7" "Disable debug endpoints" \
      "8" "Show /debug/paqet/status (text)" \
      "9" "Set snaplen=65535 + restart" \
      "10" "Live monitor (1s, Ctrl+C)" \
      "11" "Set DSCP (0 throughput / 46 low-latency)" \
      "12" "Retune KCP (fast2 + window/buffer پیشنهادی)" \
      "0" "Back")" || return 0

    case "${choice}" in
      1) support_report ;;
      2) redact_config | textbox "${APP} config" 22 78 ;;
      3) journalctl -u "${SERVICE_NAME}" -n 200 --no-pager | textbox "${APP} journal" 22 78 ;;
      4) follow_journal ;;
      5)
        local lvl
        lvl="$(menu "${APP}" "Log level:" \
          "warn" "کمترین لاگ (پیش‌فرض)" \
          "info" "برای دیباگ اتصال/فوروارد" \
          "debug" "خیلی زیاد (فقط موقت)")" || continue
        set_log_level "${lvl}" || true
        ;;
      6) set_debug_endpoints "true" "${DEBUG_PPROF_DEFAULT}" || true ;;
      7) set_debug_endpoints "false" "" || true ;;
      8) show_debug_status ;;
      9) set_snaplen "65535" || true ;;
      10) live_monitor || true ;;
      11) set_dscp_menu || true ;;
      12) retune_kcp_defaults || true ;;
      0) return 0 ;;
    esac
  done
}

set_forward_single_rule() {
  # Replace the entire top-level "forward:" block with a single TCP rule.
  # This keeps the setup predictable and avoids duplicate YAML keys.
  local listen_addr="$1" target_addr="$2"
  local tmp
  tmp="$(mktemp)"

  awk '
    BEGIN { in_fwd=0 }
    # Start of forward block
    /^[[:space:]]*forward:[[:space:]]*$/ { in_fwd=1; next }
    # End of forward block when next top-level key starts (non-indented)
    in_fwd && /^[^[:space:]][^:]*:/ { in_fwd=0 }
    # Print lines when not inside forward block
    !in_fwd { print $0 }
  ' "${CONFIG_FILE}" >"${tmp}"

  cat >>"${tmp}" <<EOF

forward:
  - listen: "${listen_addr}"
    target: "${target_addr}"
    protocol: "tcp"
EOF

  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
}

uninstall_all() {
  if ! yesno "${APP}" "این کار سرویس و فایل‌های paqet را پاک می‌کند (اما باینری‌ها را نگه می‌دارد). ادامه؟"; then
    return 0
  fi

  # Stop service first (ExecStopPost may remove iptables rules).
  systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
  remove_watchdog

  # Best-effort: remove server-side iptables rules explicitly.
  if [[ -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    "${IPTABLES_SYSTEMD_SH}" remove "${CONFIG_FILE}" || true
  fi

  systemctl disable "${SERVICE_NAME}" >/dev/null 2>&1 || true
  rm -f "${SERVICE_FILE}"
  systemctl daemon-reload >/dev/null 2>&1 || true

  rm -rf "${CONFIG_DIR}"
  rm -f "${SYSCTL_CONF}"
  sysctl --system >/dev/null 2>&1 || true

  msg "Uninstall completed. (Binary remains: ${BIN})"
}

purge_all() {
  if ! yesno "${APP}" "این کار حذف کامل انجام می‌دهد: سرویس، کانفیگ، sysctl، iptables rules و باینری‌ها. ادامه؟"; then
    return 0
  fi

  systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
  remove_watchdog
  if [[ -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    "${IPTABLES_SYSTEMD_SH}" remove "${CONFIG_FILE}" || true
  fi
  systemctl disable "${SERVICE_NAME}" >/dev/null 2>&1 || true

  rm -f "${SERVICE_FILE}" || true
  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl reset-failed "${SERVICE_NAME}" >/dev/null 2>&1 || true

  rm -rf "${CONFIG_DIR}" || true
  rm -f "${SYSCTL_CONF}" || true
  sysctl --system >/dev/null 2>&1 || true

  # Remove binaries + scripts
  rm -f "${BIN}" /usr/local/bin/paqet-ui || true
  rm -rf "${LIB_DIR}" || true

  msg "Purge completed."
}

gen_server_config() {
  local iface="$1" ip="$2" router_mac="$3" port="$4" key="$5" conn="$6" wnd="$7" smuxbuf="$8" streambuf="$9"
  local key_q
  key_q="$(yaml_quote "${key}")"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then conn=1; fi
  if ! [[ "${wnd}" =~ ^[0-9]+$ ]] || (( wnd < 1 )); then wnd=8192; fi
  if ! [[ "${smuxbuf}" =~ ^[0-9]+$ ]] || (( smuxbuf < 1024 )); then smuxbuf=$((4*1024*1024)); fi
  if ! [[ "${streambuf}" =~ ^[0-9]+$ ]] || (( streambuf < 1024 )); then streambuf=$((512*1024)); fi
  cat >"${CONFIG_FILE}" <<EOF
role: "server"

log:
  level: "warn"

listen:
  addr: ":${port}"

network:
  interface: "${iface}"
  dscp: ${DSCP_DEFAULT}
  ipv4:
    addr: "${ip}:${port}"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 33554432
    snaplen: ${PCAP_SNAPLEN}
    promisc: ${PCAP_PROMISC}
    immediate: ${PCAP_IMMEDIATE}
    timeout_ms: ${PCAP_TIMEOUT_MS}

transport:
  protocol: "kcp"
  conn: ${conn}
  kcp:
    mode: "${KCP_MODE}"
    mtu: ${KCP_MTU}
    rcvwnd: ${wnd}
    sndwnd: ${wnd}
    block: "aes"
    key: ${key_q}
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    max_sessions: 2048
    max_streams_total: 262144
    max_streams_per_session: 32768
    header_timeout: 10
    smuxbuf: ${smuxbuf}
    streambuf: ${streambuf}
EOF
}

gen_client_config_no_socks() {
  # X-UI only mode: do not generate a SOCKS listener at all.
  local iface="$1" ip="$2" router_mac="$3" local_port="$4" remote_ip="$5" port="$6" key="$7" conn="$8" wnd="$9" smuxbuf="${10}" streambuf="${11}"
  local key_q
  key_q="$(yaml_quote "${key}")"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi
  if (( conn > 256 )); then
    conn=256
  fi
  if ! [[ "${wnd}" =~ ^[0-9]+$ ]] || (( wnd < 1 )); then wnd=8192; fi
  if ! [[ "${smuxbuf}" =~ ^[0-9]+$ ]] || (( smuxbuf < 1024 )); then smuxbuf=$((4*1024*1024)); fi
  if ! [[ "${streambuf}" =~ ^[0-9]+$ ]] || (( streambuf < 1024 )); then streambuf=$((512*1024)); fi
  cat >"${CONFIG_FILE}" <<EOF
role: "client"

log:
  level: "warn"

network:
  interface: "${iface}"
  dscp: ${DSCP_DEFAULT}
  ipv4:
    addr: "${ip}:${local_port}"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 33554432
    snaplen: ${PCAP_SNAPLEN}
    promisc: ${PCAP_PROMISC}
    immediate: ${PCAP_IMMEDIATE}
    timeout_ms: ${PCAP_TIMEOUT_MS}

server:
  addr: "${remote_ip}:${port}"

transport:
  protocol: "kcp"
  conn: ${conn}
  kcp:
    mode: "${KCP_MODE}"
    mtu: ${KCP_MTU}
    rcvwnd: ${wnd}
    sndwnd: ${wnd}
    block: "aes"
    key: ${key_q}
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    header_timeout: 10
    smuxbuf: ${smuxbuf}
    streambuf: ${streambuf}
EOF
}

setup_outside_server() {
  local iface ip gw mac port key
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  # Simple defaults (no port prompts unless busy)
  port="9999"
  port="$(ensure_tcp_port_free_or_prompt_simple "${port}" "Tunnel port (server)" )" || return 1

  key="$("${BIN}" secret)"
  local conn wnd smuxbuf streambuf
  conn="$(pick_client_conn)"
  conn="$(adjust_conn_to_free_server_port_range "${port}" "${conn}")"
  wnd="$(pick_kcp_window "${conn}")"
  smuxbuf="$(pick_smuxbuf)"
  streambuf="$(pick_streambuf)"

  mkdir -p "${CONFIG_DIR}"
  gen_server_config "${iface}" "${ip}" "${mac}" "${port}" "${key}" "${conn}" "${wnd}" "${smuxbuf}" "${streambuf}"
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  local end_port
  end_port=$(( port + conn - 1 ))
  if (( conn > 1 )); then
    msg "سرور خارج ستاپ شد.\n\nTunnel ports: ${port}-${end_port}  (kcp conns: ${conn})\n\nکلید Pairing (این را به سرور داخل بده):\n${key}\n\nStatus از منو قابل مشاهده است."
  else
    msg "سرور خارج ستاپ شد.\n\nTunnel port: ${port}\n\nکلید Pairing (این را به سرور داخل بده):\n${key}\n\nStatus از منو قابل مشاهده است."
  fi
}

setup_inside_xui_only() {
  # One-step inside setup for X-UI only (no SOCKS, no extra ports):
  # Listens on 0.0.0.0:<public_port> and forwards via tunnel to outside 127.0.0.1:2443.
  local iface ip gw mac remote key public_port xray_port listen_addr target_addr local_port conn local_end
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  remote="$(input "${APP}" "IP سرور خارج؟ (مثال: 1.2.3.4)" "")" || return 1
  port="9999"
  key="$(password "${APP}" "کلید Pairing که روی سرور خارج نمایش داده شد را وارد کن")" || return 1

  public_port="443"
  public_port="$(ensure_tcp_port_free_or_prompt "${public_port}" "X-UI entrypoint (inside)" )" || return 1

  xray_port="2443"
  listen_addr="0.0.0.0:${public_port}"
  target_addr="127.0.0.1:${xray_port}"

  conn="$(pick_client_conn)"
  local_port="$(pick_client_raw_port_range "${conn}")"
  local_end=$(( local_port + conn - 1 ))
  local wnd smuxbuf streambuf
  wnd="$(pick_kcp_window "${conn}")"
  smuxbuf="$(pick_smuxbuf)"
  streambuf="$(pick_streambuf)"

  mkdir -p "${CONFIG_DIR}"
  gen_client_config_no_socks "${iface}" "${ip}" "${mac}" "${local_port}" "${remote}" "${port}" "${key}" "${conn}" "${wnd}" "${smuxbuf}" "${streambuf}"
  set_forward_single_rule "${listen_addr}" "${target_addr}"
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  msg "سرور داخل برای X-UI ستاپ شد.\n\nForward:\n  ${listen_addr}  ->  ${target_addr}\n\nTransport:\n  kcp sessions: ${conn}\n  client raw port range: ${local_port}-${local_end}\n\nروی سرور خارج در x-ui inbound بساز:\n  VLESS / TCP\n  listen: 127.0.0.1\n  port:   ${xray_port}\n\nبعد روی کلاینت‌ها:\n  address = IP ایران\n  port    = ${public_port}"
}

main_loop() {
  while true; do
    local choice
    choice="$(menu "${APP}" "یک گزینه را انتخاب کن:" \
      "1" "ستاپ سرور خارج (Server)" \
      "15" "Setup inside (X-UI only, one-step, no SOCKS)" \
      "3" "Status" \
      "4" "Diagnostics / Debug" \
      "6" "Stop service" \
      "7" "Uninstall (keep binaries)" \
      "13" "Purge (remove everything)" \
      "0" "Exit")" || exit 0

    case "${choice}" in
      1) setup_outside_server ;;
      15) setup_inside_xui_only ;;
      3) status_screen ;;
      4) diagnostics_loop ;;
      6) systemctl stop "${SERVICE_NAME}" || true ;;
      7) uninstall_all ;;
      13) purge_all ;;
      0) exit 0 ;;
    esac
  done
}

need_root "$@"
ensure_deps
main_loop
