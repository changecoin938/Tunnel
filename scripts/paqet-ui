#!/usr/bin/env bash
set -euo pipefail

# Ensure whiptail runs on a real TTY (important when launched via `curl | bash`).
if [[ ! -t 0 || ! -t 1 || ! -t 2 ]]; then
  if [[ -r /dev/tty && -w /dev/tty ]]; then
    exec </dev/tty >/dev/tty 2>/dev/tty
  else
    echo "No interactive TTY available. Run: sudo paqet-ui" >&2
    exit 1
  fi
fi

# Fix for unknown TERM values (wezterm/xterm-kitty/etc.) when terminfo isn't installed.
# If termcap init fails, fall back to a widely-supported TERM.
if command -v tput >/dev/null 2>&1; then
  if ! tput sgr0 >/dev/null 2>&1; then
    export TERM=xterm-256color
    tput sgr0 >/dev/null 2>&1 || export TERM=xterm
  fi
fi

# Make sure the terminal isn't stuck in a weird mode (can break arrow keys).
stty sane >/dev/null 2>&1 || true
trap 'stty sane >/dev/null 2>&1 || true' EXIT

APP="paqet"
BIN="/usr/local/bin/paqet"

CONFIG_DIR="/etc/paqet"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"

LIB_DIR="/usr/local/lib/paqet"
IPTABLES_SH="${LIB_DIR}/paqet-iptables.sh"

SERVICE_NAME="paqet"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"

SYSCTL_CONF="/etc/sysctl.d/99-paqet.conf"

need_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    exec sudo -E "$0" "$@"
  fi
}

need_cmd() { command -v "$1" >/dev/null 2>&1; }

ensure_deps() {
  local missing=()
  for c in whiptail ip ss iptables systemctl awk sed grep cut tr head tail curl; do
    need_cmd "$c" || missing+=("$c")
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Missing deps: ${missing[*]}" >&2
    echo "Run: sudo apt-get update && sudo apt-get install -y whiptail iproute2 iptables" >&2
    exit 1
  fi
  if [[ ! -x "${BIN}" ]]; then
    echo "Binary not found at ${BIN}. Run install.sh first." >&2
    exit 1
  fi
}

msg() { whiptail --title "${APP}" --msgbox "$1" 12 78; }

input() {
  local title="$1" prompt="$2" def="${3:-}"
  local out
  out="$(whiptail --title "${title}" --inputbox "${prompt}" 12 78 "${def}" 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

password() {
  local title="$1" prompt="$2"
  local out
  out="$(whiptail --title "${title}" --passwordbox "${prompt}" 12 78 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

yesno() {
  local title="$1" prompt="$2"
  if whiptail --title "${title}" --yesno "${prompt}" 12 78; then
    return 0
  fi
  return 1
}

menu() {
  local title="$1" prompt="$2"
  shift 2
  whiptail --title "${title}" --menu "${prompt}" 18 78 10 "$@" 3>&1 1>&2 2>&3
}

ss_listen_tcp() {
  # Output TCP LISTEN sockets for a port (best-effort).
  local port="$1"
  ss -lntpH "sport = :${port}" 2>/dev/null || true
}

extract_pids_from_ss() {
  # Extract pid list from ss output.
  grep -oE 'pid=[0-9]+' | cut -d= -f2 | sort -u
}

is_tcp_port_listening() {
  local port="$1"
  local out
  out="$(ss_listen_tcp "${port}")"
  [[ -n "${out}" ]]
}

kill_port_pids() {
  local port="$1"
  local out pids
  out="$(ss_listen_tcp "${port}")"
  pids="$(printf "%s\n" "${out}" | extract_pids_from_ss || true)"
  if [[ -z "${pids}" ]]; then
    msg "نتونستم PID رو از ss پیدا کنم.\n\n${out}"
    return 1
  fi

  if ! yesno "${APP}" "این PIDها روی پورت ${port} گوش میدن:\n${pids}\n\nKill کنیم؟"; then
    return 1
  fi

  for pid in ${pids}; do
    kill -TERM "${pid}" >/dev/null 2>&1 || true
  done
  sleep 1
  for pid in ${pids}; do
    kill -KILL "${pid}" >/dev/null 2>&1 || true
  done
  return 0
}

ensure_tcp_port_free_or_prompt() {
  # Loops until port is free, or user cancels. Prints the chosen port.
  local port="$1"
  local purpose="$2"

  while is_tcp_port_listening "${port}"; do
    local out choice
    out="$(ss_listen_tcp "${port}")"
    choice="$(menu "${APP}" "پورت ${port} برای ${purpose} مشغول است.\n\n${out}\n\nچه کار کنیم؟" \
      "1" "Stop paqet service (اگر خودش گرفته)" \
      "2" "Kill process(es) on this port" \
      "3" "Choose a different port" \
      "0" "Cancel")" || return 1

    case "${choice}" in
      1)
        systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
        ;;
      2)
        kill_port_pids "${port}" || true
        ;;
      3)
        port="$(input "${APP}" "پورت جدید برای ${purpose}:" "${port}")" || return 1
        ;;
      0)
        return 1
        ;;
    esac
  done

  printf "%s" "${port}"
}

ensure_service_can_reconfigure() {
  # If service is active, ask user to stop or cancel.
  if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
    if yesno "${APP}" "سرویس ${SERVICE_NAME} الان فعاله. برای ستاپ جدید باید متوقف بشه.\n\nStop کنیم؟"; then
      systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
    else
      return 1
    fi
  fi
  return 0
}

detect_default_iface() {
  ip route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="dev") {print $(i+1); exit}}'
}

detect_local_ipv4() {
  local iface="$1"
  ip -4 -o addr show dev "${iface}" scope global 2>/dev/null | awk '{print $4}' | head -n1 | cut -d/ -f1
}

detect_gateway_ipv4() {
  ip -4 route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="via") {print $(i+1); exit}}'
}

detect_gateway_mac() {
  local gw="$1" iface="$2"
  ip neigh show "${gw}" dev "${iface}" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="lladdr") {print $(i+1); exit}}'
}

ensure_gateway_mac() {
  local gw="$1" iface="$2"
  local mac
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  ping -c 1 -W 1 "${gw}" >/dev/null 2>&1 || true
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  return 1
}

write_sysctl_defaults() {
  cat >"${SYSCTL_CONF}" <<'EOF'
# paqet baseline tuning (adjust per host/RAM/NIC)
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.core.rmem_default = 8388608
net.core.wmem_default = 8388608
net.core.netdev_max_backlog = 250000
EOF
  sysctl --system >/dev/null 2>&1 || true
}

install_service() {
  mkdir -p "${CONFIG_DIR}" "${LIB_DIR}"

  if [[ ! -x "${IPTABLES_SH}" ]]; then
    msg "iptables helper not found at ${IPTABLES_SH}. Re-install scripts."
    return 1
  fi

  cat >"${SERVICE_FILE}" <<EOF
[Unit]
Description=paqet tunnel
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStartPre=/bin/bash -lc 'port=\$(grep -E \"^\\s*addr:\\s*\\\"?:[0-9]+\\\"?\" -n ${CONFIG_FILE} | head -n1 | sed -E \"s/.*:([0-9]+)\\\"?\\s*$/\\1/\"); if [[ -n \"\$port\" ]]; then ${IPTABLES_SH} apply \"\$port\" || true; fi'
ExecStart=${BIN} run -c ${CONFIG_FILE}
ExecStopPost=/bin/bash -lc 'port=\$(grep -E \"^\\s*addr:\\s*\\\"?:[0-9]+\\\"?\" -n ${CONFIG_FILE} | head -n1 | sed -E \"s/.*:([0-9]+)\\\"?\\s*$/\\1/\"); if [[ -n \"\$port\" ]]; then ${IPTABLES_SH} remove \"\$port\" || true; fi'
Restart=on-failure
RestartSec=1
LimitNOFILE=1048576

# Hardening (keep compatible with raw sockets)
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${SERVICE_NAME}" >/dev/null 2>&1 || true
}

start_service() {
  systemctl restart "${SERVICE_NAME}"
}

status_screen() {
  local out
  out="$(systemctl status "${SERVICE_NAME}" --no-pager 2>&1 || true)"
  whiptail --title "${APP} status" --scrolltext --textbox <(printf "%s\n" "${out}") 22 78
}

logs_screen() {
  local out
  out="$(journalctl -u "${SERVICE_NAME}" -n 200 --no-pager 2>&1 || true)"
  whiptail --title "${APP} logs (last 200)" --scrolltext --textbox <(printf "%s\n" "${out}") 22 78
}

get_pprof_addr_from_config() {
  if [[ -f "${CONFIG_FILE}" ]]; then
    local a
    a="$(grep -E '^[[:space:]]*pprof:[[:space:]]*' "${CONFIG_FILE}" | head -n1 | sed -E 's/^[[:space:]]*pprof:[[:space:]]*\"?([^\"[:space:]]+)\"?.*$/\\1/')"
    if [[ -n "${a}" ]]; then
      printf "%s" "${a}"
      return 0
    fi
  fi
  printf "%s" "127.0.0.1:6060"
}

diag_text_fetch() {
  local addr
  addr="$(get_pprof_addr_from_config)"
  curl -fsS --max-time 2 "http://${addr}/debug/paqet/text" 2>&1
}

diag_text_screen() {
  local out
  out="$(diag_text_fetch || true)"
  if echo "${out}" | grep -qiE 'connection refused|failed to connect|could not resolve|404'; then
    out="${out}\n\nNOTE: detailed tunnel status needs debug.pprof enabled and paqet restarted.\nConfig: debug.pprof: \"127.0.0.1:6060\""
  fi
  whiptail --title "${APP} tunnel status (detailed)" --scrolltext --textbox <(printf "%b\n" "${out}") 22 78
}

diag_json_fetch() {
  local addr
  addr="$(get_pprof_addr_from_config)"
  curl -fsS --max-time 2 "http://${addr}/debug/paqet/status" 2>&1
}

diag_json_screen() {
  local out
  out="$(diag_json_fetch || true)"
  if echo "${out}" | grep -qiE 'connection refused|failed to connect|could not resolve|404'; then
    out="${out}\n\nNOTE: JSON status needs debug.pprof enabled and paqet restarted.\nConfig: debug.pprof: \"127.0.0.1:6060\""
  fi
  whiptail --title "${APP} tunnel status (json)" --scrolltext --textbox <(printf "%b\n" "${out}") 22 78
}

get_role_from_config() {
  if [[ -f "${CONFIG_FILE}" ]]; then
    grep -E '^[[:space:]]*role:[[:space:]]*' "${CONFIG_FILE}" | head -n1 | sed -E 's/^[[:space:]]*role:[[:space:]]*\"?([^\"[:space:]]+)\"?.*$/\\1/'
  fi
}

get_socks_listen_from_config() {
  if [[ -f "${CONFIG_FILE}" ]]; then
    grep -E '^[[:space:]]*listen:[[:space:]]*' "${CONFIG_FILE}" | head -n1 | sed -E 's/^[[:space:]]*listen:[[:space:]]*\"?([^\"[:space:]]+)\"?.*$/\\1/'
  fi
}

has_forward_section() {
  [[ -f "${CONFIG_FILE}" ]] && grep -qE '^[[:space:]]*forward:[[:space:]]*$' "${CONFIG_FILE}"
}

add_or_replace_forward_rule() {
  # Adds (or replaces) a single TCP forward rule:
  # listen => target (server-side), protocol=tcp
  local listen_addr="$1" target_addr="$2"
  local tmp
  tmp="$(mktemp)"

  # If a forward section exists, we append a new rule at the end of that section.
  # Otherwise, we insert a new forward section after the socks5 block (if present),
  # else near the top.
  if has_forward_section; then
    # Simple append at end of file (valid YAML, keeps existing forwards).
    cat "${CONFIG_FILE}" >"${tmp}"
    cat >>"${tmp}" <<EOF

forward:
  - listen: "${listen_addr}"
    target: "${target_addr}"
    protocol: "tcp"
EOF
  else
    # Insert after socks5 block if present, else after debug block, else at top after log.
    awk -v listen_addr="${listen_addr}" -v target_addr="${target_addr}" '
      BEGIN { inserted=0 }
      {
        print $0
        if (!inserted && $0 ~ /^[[:space:]]*socks5:[[:space:]]*$/) {
          # Keep printing socks5 block; insertion happens after it ends.
          in_socks=1
        } else if (in_socks) {
          # socks5 block ends when we hit a non-indented line (new top-level key) or EOF.
          if ($0 ~ /^[^[:space:]]/ && $0 !~ /^socks5:/) {
            # We already printed this top-level line; insert before it by re-printing not possible.
            # So instead we insert right before this line by using a buffer approach is complex.
            # Workaround: insert when we encounter the next top-level key after socks5 by printing
            # the forward section just before that key: we do it by printing it now and then re-printing line.
          }
        }
      }
    ' "${CONFIG_FILE}" >/dev/null 2>&1

    # Use a safer approach: split into head (through socks5 block) and tail (rest),
    # then concatenate with forward section in between.
    local socks_start socks_end
    socks_start="$(grep -nE '^[[:space:]]*socks5:[[:space:]]*$' "${CONFIG_FILE}" | head -n1 | cut -d: -f1 || true)"
    if [[ -n "${socks_start}" ]]; then
      # socks block ends at next top-level key after socks_start
      socks_end="$(tail -n +$((socks_start+1)) "${CONFIG_FILE}" | grep -nE '^[^[:space:]][^:]*:' | head -n1 | cut -d: -f1 || true)"
      if [[ -n "${socks_end}" ]]; then
        socks_end=$((socks_start + socks_end - 1))
      else
        socks_end="$(wc -l <"${CONFIG_FILE}")"
      fi
      head -n "${socks_end}" "${CONFIG_FILE}" >"${tmp}"
      cat >>"${tmp}" <<EOF

forward:
  - listen: "${listen_addr}"
    target: "${target_addr}"
    protocol: "tcp"
EOF
      tail -n +$((socks_end+1)) "${CONFIG_FILE}" >>"${tmp}"
    else
      cat "${CONFIG_FILE}" >"${tmp}"
      cat >>"${tmp}" <<EOF

forward:
  - listen: "${listen_addr}"
    target: "${target_addr}"
    protocol: "tcp"
EOF
    fi
  fi

  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
}

enable_vless_relay_wizard() {
  # This is the "no manual editing" path to use Xray/V2Ray (VLESS) behind paqet:
  # - Outside (server) runs Xray inbound on 127.0.0.1:<xray_port>
  # - Inside (client) listens on 0.0.0.0:<public_port> and forwards through tunnel to 127.0.0.1:<xray_port> (server-side)
  local role public_port xray_port listen_addr target_addr

  role="$(get_role_from_config || true)"
  if [[ "${role}" != "client" ]]; then
    msg "این گزینه فقط روی سرور داخل (client) کار می‌کنه.\n\nروی سرور خارج لازم نیست چیزی انجام بدی جز ساخت inbound در x-ui."
    return 0
  fi
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    msg "کانفیگ پیدا نشد: ${CONFIG_FILE}\n\nاول گزینه «ستاپ سرور داخل» رو اجرا کن."
    return 0
  fi

  ensure_service_can_reconfigure || return 1

  public_port="$(input "${APP}" "پورت عمومی روی ایران برای VLESS؟ (دیفالت 443)" "443")" || return 1
  public_port="$(ensure_tcp_port_free_or_prompt "${public_port}" "VLESS entrypoint (inside)" )" || return 1

  xray_port="$(input "${APP}" "پورت inbound روی سرور خارج (x-ui)؟ (دیفالت 2443)" "2443")" || return 1
  if [[ ! "${xray_port}" =~ ^[0-9]+$ ]] || (( xray_port < 1 || xray_port > 65535 )); then
    msg "پورت نامعتبر: ${xray_port}"
    return 1
  fi

  listen_addr="0.0.0.0:${public_port}"
  target_addr="127.0.0.1:${xray_port}"

  add_or_replace_forward_rule "${listen_addr}" "${target_addr}"

  install_service
  start_service

  msg "✅ VLESS Relay فعال شد.\n\nروی سرور خارج در x-ui یک inbound بساز:\n  VLESS / TCP\n  listen: 127.0.0.1\n  port:   ${xray_port}\n\nبعد روی کلاینت‌ها:\n  address = IP ایران\n  port    = ${public_port}\n  uuid/flow/... = همون x-ui"
}

socks_test_screen() {
  local role socks out
  role="$(get_role_from_config || true)"
  if [[ "${role}" != "client" ]]; then
    msg "این گزینه فقط برای سرور داخل (client) است."
    return 0
  fi
  socks="$(get_socks_listen_from_config || true)"
  if [[ -z "${socks}" ]]; then
    socks="127.0.0.1:1080"
  fi

  out="$(curl -fsS -o /dev/null --max-time 15 \
    --proxy "socks5h://${socks}" \
    -w "proxy=${socks}\nhttp_code=%{http_code}\ntime_total=%{time_total}s\n" \
    https://www.gstatic.com/generate_204 2>&1 || true)"

  if echo "${out}" | grep -qiE 'failed|refused|timeout|could not|error'; then
    out="${out}\n\nTip: مطمئن شو SOCKS5 روی همین سرور بالا هست: ss -lntp | grep 1080"
  fi
  whiptail --title "${APP} SOCKS5 test" --scrolltext --textbox <(printf "%b\n" "${out}") 18 78
}

extract_bytes_line() {
  # input: diag text
  # output: "up down" or empty
  sed -nE 's/^  bytes: up=([0-9]+)  down=([0-9]+)$/\\1 \\2/p' | head -n1
}

throughput_screen() {
  local a b up1 down1 up2 down2 d_up d_down out
  a="$(diag_text_fetch || true)"
  if [[ -z "${a}" ]]; then
    msg "Could not fetch diagnostics. Is paqet running and debug.pprof enabled?"
    return 0
  fi
  read -r up1 down1 < <(printf "%s\n" "${a}" | extract_bytes_line || true)
  sleep 1
  b="$(diag_text_fetch || true)"
  read -r up2 down2 < <(printf "%s\n" "${b}" | extract_bytes_line || true)

  if [[ -z "${up1:-}" || -z "${down1:-}" || -z "${up2:-}" || -z "${down2:-}" ]]; then
    msg "Failed to parse counters. (Try Detailed Status first.)"
    return 0
  fi

  d_up=$((up2-up1))
  d_down=$((down2-down1))
  out="Estimated throughput (1s sample)\n\n  up:   ${d_up} B/s\n  down: ${d_down} B/s\n\n(Values are tunnel payload bytes since start; sample uses /debug/paqet/text)"
  msg "${out}"
}

uninstall_all() {
  if ! yesno "${APP}" "این کار سرویس و فایل‌های paqet را پاک می‌کند. ادامه؟"; then
    return 0
  fi
  systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
  systemctl disable "${SERVICE_NAME}" >/dev/null 2>&1 || true
  rm -f "${SERVICE_FILE}"
  systemctl daemon-reload >/dev/null 2>&1 || true
  rm -rf "${CONFIG_DIR}"
  rm -f "${SYSCTL_CONF}"
  msg "Uninstall completed. (Binary remains: ${BIN})"
}

gen_server_config() {
  local iface="$1" ip="$2" router_mac="$3" port="$4" key="$5"
  cat >"${CONFIG_FILE}" <<EOF
role: "server"

log:
  level: "info"

debug:
  pprof: "127.0.0.1:6060"

listen:
  addr: ":${port}"

network:
  interface: "${iface}"
  ipv4:
    addr: "${ip}:${port}"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 33554432

transport:
  protocol: "kcp"
  conn: 1
  kcp:
    mode: "fast2"
    mtu: 1350
    rcvwnd: 8192
    sndwnd: 8192
    block: "aes"
    key: "${key}"
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    max_sessions: 2048
    max_streams_total: 65536
    max_streams_per_session: 8192
    header_timeout: 10
    smuxbuf: 16777216
    streambuf: 4194304
EOF
}

gen_client_config() {
  local iface="$1" ip="$2" router_mac="$3" remote_ip="$4" port="$5" key="$6" socks_listen="$7" user="$8" pass="$9"
  cat >"${CONFIG_FILE}" <<EOF
role: "client"

log:
  level: "info"

debug:
  pprof: "127.0.0.1:6060"

socks5:
  - listen: "${socks_listen}"
    username: "${user}"
    password: "${pass}"

network:
  interface: "${iface}"
  ipv4:
    addr: "${ip}:0"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 16777216

server:
  addr: "${remote_ip}:${port}"

transport:
  protocol: "kcp"
  conn: 4
  kcp:
    mode: "fast2"
    mtu: 1350
    rcvwnd: 4096
    sndwnd: 4096
    block: "aes"
    key: "${key}"
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    header_timeout: 10
    smuxbuf: 16777216
    streambuf: 4194304
EOF
}

setup_outside_server() {
  local iface ip gw mac port key
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  port="$(input "${APP}" "پورت سرور خارج؟ (پیش‌فرض 9999)" "9999")" || return 1
  port="$(ensure_tcp_port_free_or_prompt "${port}" "Tunnel port (server)" )" || return 1

  # debug/status port (pprof host)
  local dbg_port
  dbg_port="6060"
  dbg_port="$(ensure_tcp_port_free_or_prompt "${dbg_port}" "Debug/Status (pprof)" )" || return 1

  key="$("${BIN}" secret)"

  mkdir -p "${CONFIG_DIR}"
  gen_server_config "${iface}" "${ip}" "${mac}" "${port}" "${key}"
  # If user picked non-default debug port, patch config.
  if [[ "${dbg_port}" != "6060" ]]; then
    sed -i -E "s/pprof: \"127\\.0\\.0\\.1:6060\"/pprof: \"127.0.0.1:${dbg_port}\"/" "${CONFIG_FILE}" || true
  fi
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  msg "سرور خارج ستاپ شد.\n\nکلید Pairing (این را به سرور داخل بده):\n${key}\n\nStatus از منو قابل مشاهده است."
}

setup_inside_server() {
  local iface ip gw mac port remote key socks_host socks_port socks_listen user pass
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  remote="$(input "${APP}" "IP سرور خارج؟ (مثال: 1.2.3.4)" "")" || return 1
  port="$(input "${APP}" "پورت سرور خارج؟ (پیش‌فرض 9999)" "9999")" || return 1
  key="$(password "${APP}" "کلید Pairing که روی سرور خارج نمایش داده شد را وارد کن")" || return 1

  socks_host="127.0.0.1"
  if yesno "${APP}" "SOCKS5 روی 0.0.0.0:1080 باز شود؟ (فقط اگر می‌دانی چه می‌کنی)"; then
    socks_host="0.0.0.0"
  fi
  socks_port="$(input "${APP}" "پورت SOCKS5؟ (پیش‌فرض 1080)" "1080")" || return 1
  socks_port="$(ensure_tcp_port_free_or_prompt "${socks_port}" "SOCKS5" )" || return 1
  socks_listen="${socks_host}:${socks_port}"

  # debug/status port (pprof host)
  local dbg_port
  dbg_port="6060"
  dbg_port="$(ensure_tcp_port_free_or_prompt "${dbg_port}" "Debug/Status (pprof)" )" || return 1

  user=""
  pass=""
  if yesno "${APP}" "برای SOCKS5 یوزر/پسورد بگذاریم؟ (پیشنهادی)"; then
    user="$(input "${APP}" "Username:" "user")" || return 1
    pass="$(password "${APP}" "Password:" )" || return 1
  fi

  mkdir -p "${CONFIG_DIR}"
  gen_client_config "${iface}" "${ip}" "${mac}" "${remote}" "${port}" "${key}" "${socks_listen}" "${user}" "${pass}"
  if [[ "${dbg_port}" != "6060" ]]; then
    sed -i -E "s/pprof: \"127\\.0\\.0\\.1:6060\"/pprof: \"127.0.0.1:${dbg_port}\"/" "${CONFIG_FILE}" || true
  fi
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  msg "سرور داخل (کلاینت) ستاپ شد.\n\nSOCKS5: ${socks_listen}\nخارج: ${remote}:${port}"
}

main_loop() {
  while true; do
    local choice
    choice="$(menu "${APP}" "یک گزینه را انتخاب کن:" \
      "1" "ستاپ سرور خارج (Server)" \
      "2" "ستاپ سرور داخل (Client + SOCKS5)" \
      "12" "Enable VLESS relay (x-ui on outside, no panel inside)" \
      "3" "Status" \
      "4" "Logs" \
      "8" "Tunnel status (detailed)" \
      "9" "Traffic rate (1s sample)" \
      "10" "Tunnel status (json)" \
      "11" "SOCKS5 test (client)" \
      "5" "Restart service" \
      "6" "Stop service" \
      "7" "Uninstall" \
      "0" "Exit")" || exit 0

    case "${choice}" in
      1) setup_outside_server ;;
      2) setup_inside_server ;;
      12) enable_vless_relay_wizard ;;
      3) status_screen ;;
      4) logs_screen ;;
      8) diag_text_screen ;;
      9) throughput_screen ;;
      10) diag_json_screen ;;
      11) socks_test_screen ;;
      5) systemctl restart "${SERVICE_NAME}" || msg "restart failed" ;;
      6) systemctl stop "${SERVICE_NAME}" || true ;;
      7) uninstall_all ;;
      0) exit 0 ;;
    esac
  done
}

need_root "$@"
ensure_deps
main_loop


