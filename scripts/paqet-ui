#!/usr/bin/env bash
set -euo pipefail

# Ensure whiptail runs on a real TTY (important when launched via `curl | bash`).
if [[ ! -t 0 || ! -t 1 || ! -t 2 ]]; then
  if [[ -r /dev/tty && -w /dev/tty ]]; then
    exec </dev/tty >/dev/tty 2>/dev/tty
  else
    echo "No interactive TTY available. Run: sudo paqet-ui" >&2
    exit 1
  fi
fi

# Fix for unknown TERM values (wezterm/xterm-kitty/etc.) when terminfo isn't installed.
# If termcap init fails, fall back to a widely-supported TERM.
if command -v tput >/dev/null 2>&1; then
  if ! tput sgr0 >/dev/null 2>&1; then
    export TERM=xterm-256color
    tput sgr0 >/dev/null 2>&1 || export TERM=xterm
  fi
fi

# Make sure the terminal isn't stuck in a weird mode (can break arrow keys).
stty sane >/dev/null 2>&1 || true
trap 'stty sane >/dev/null 2>&1 || true' EXIT

APP="paqet"
BIN="/usr/local/bin/paqet"

CONFIG_DIR="/etc/paqet"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"

LIB_DIR="/usr/local/lib/paqet"
IPTABLES_SH="${LIB_DIR}/paqet-iptables.sh"
IPTABLES_SYSTEMD_SH="${LIB_DIR}/paqet-systemd-iptables.sh"

SERVICE_NAME="paqet"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"

SYSCTL_CONF="/etc/sysctl.d/99-paqet.conf"

# rand_alnum prints a random alphanumeric string of length N (default 24).
rand_alnum() {
  local n="${1:-24}"
  if [[ -r /dev/urandom ]]; then
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "${n}"
    return 0
  fi
  # Fallback (should be rare).
  date +%s%N | tr -dc '0-9' | head -c "${n}"
}

# yaml_quote returns a safely single-quoted YAML scalar.
yaml_quote() {
  local s="${1-}"
  s="${s//$'\r'/}"
  s="${s//$'\n'/}"
  s="${s//\'/\'\'}"
  printf "'%s'" "${s}"
}

# Tunnel defaults (high-throughput). These are embedded in generated configs.
KCP_MODE="fast"
KCP_MTU="1350"
PCAP_SNAPLEN="65535"
PCAP_PROMISC="false"
PCAP_IMMEDIATE="true"
PCAP_TIMEOUT_MS="0"

# Client raw TCP port (local). We pick a stable port below the OS ephemeral range
# to reduce collisions with normal outbound connections and to allow iptables rules
# (RST-drop / NOTRACK) to be applied reliably by systemd helper scripts.
CLIENT_RAW_PORT_DEFAULT="20000"

pick_client_conn() {
  # Choose a reasonable default number of parallel KCP sessions for higher throughput.
  # More connections = more CPU and more parallelism.
  local n
  n="$(getconf _NPROCESSORS_ONLN 2>/dev/null || nproc 2>/dev/null || echo 1)"
  if ! [[ "${n}" =~ ^[0-9]+$ ]]; then
    n=1
  fi
  if (( n <= 2 )); then
    echo 1
  elif (( n <= 4 )); then
    echo 2
  elif (( n <= 8 )); then
    echo 4
  else
    # For 16c+ boxes, 8 parallel sessions is a good baseline.
    echo 8
  fi
}

pick_client_raw_port() {
  # Choose a port that is not LISTENing locally (best-effort) and stays below common ephemeral ranges.
  local p
  p="${CLIENT_RAW_PORT_DEFAULT}"
  while (( p < 30000 )); do
    if ! is_tcp_port_listening "${p}"; then
      printf "%s" "${p}"
      return 0
    fi
    p=$((p+1))
  done
  # Fallback: still return default (iptables helper may skip if conflicts are real).
  printf "%s" "${CLIENT_RAW_PORT_DEFAULT}"
  return 0
}

pick_client_raw_port_range() {
  # Pick a base port such that [base..base+conn-1] is free of LISTEN sockets.
  local conn="${1:-1}"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi

  local base end p
  base="${CLIENT_RAW_PORT_DEFAULT}"
  while (( base < 30000 )); do
    end=$(( base + conn - 1 ))
    if (( end > 65535 )); then
      break
    fi
    local ok="1"
    for ((p=base; p<=end; p++)); do
      if is_tcp_port_listening "${p}"; then
        ok="0"
        break
      fi
    done
    if [[ "${ok}" == "1" ]]; then
      printf "%s" "${base}"
      return 0
    fi
    base=$((base+1))
  done

  printf "%s" "${CLIENT_RAW_PORT_DEFAULT}"
  return 0
}

need_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    exec sudo -E "$0" "$@"
  fi
}

need_cmd() { command -v "$1" >/dev/null 2>&1; }

ensure_deps() {
  local missing=()
  for c in whiptail ip ss iptables systemctl awk sed grep cut tr head tail curl; do
    need_cmd "$c" || missing+=("$c")
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Missing deps: ${missing[*]}" >&2
    echo "Run: sudo apt-get update && sudo apt-get install -y whiptail iproute2 iptables" >&2
    exit 1
  fi
  if [[ ! -x "${BIN}" ]]; then
    echo "Binary not found at ${BIN}. Run install.sh first." >&2
    exit 1
  fi
}

msg() { whiptail --title "${APP}" --msgbox "$1" 12 78; }

textbox() {
  # Safer than process substitution; works reliably across environments.
  local title="$1" height="${2:-22}" width="${3:-78}"
  local tmp
  tmp="$(mktemp)"
  cat >"${tmp}"
  whiptail --title "${title}" --scrolltext --textbox "${tmp}" "${height}" "${width}"
  rm -f "${tmp}"
}

input() {
  local title="$1" prompt="$2" def="${3:-}"
  local out
  out="$(whiptail --title "${title}" --inputbox "${prompt}" 12 78 "${def}" 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

password() {
  local title="$1" prompt="$2"
  local out
  out="$(whiptail --title "${title}" --passwordbox "${prompt}" 12 78 3>&1 1>&2 2>&3)" || return 1
  printf "%s" "${out}"
}

yesno() {
  local title="$1" prompt="$2"
  if whiptail --title "${title}" --yesno "${prompt}" 12 78; then
    return 0
  fi
  return 1
}

menu() {
  local title="$1" prompt="$2"
  shift 2
  whiptail --title "${title}" --menu "${prompt}" 18 78 10 "$@" 3>&1 1>&2 2>&3
}

ss_listen_tcp() {
  # Output TCP LISTEN sockets for a port (best-effort).
  local port="$1"
  ss -lntpH "sport = :${port}" 2>/dev/null || true
}

extract_pids_from_ss() {
  # Extract pid list from ss output.
  grep -oE 'pid=[0-9]+' | cut -d= -f2 | sort -u
}

is_tcp_port_listening() {
  local port="$1"
  local out
  out="$(ss_listen_tcp "${port}")"
  [[ -n "${out}" ]]
}

kill_port_pids() {
  local port="$1"
  local out pids
  out="$(ss_listen_tcp "${port}")"
  pids="$(printf "%s\n" "${out}" | extract_pids_from_ss || true)"
  if [[ -z "${pids}" ]]; then
    msg "نتونستم PID رو از ss پیدا کنم.\n\n${out}"
    return 1
  fi

  if ! yesno "${APP}" "این PIDها روی پورت ${port} گوش میدن:\n${pids}\n\nKill کنیم؟"; then
    return 1
  fi

  for pid in ${pids}; do
    kill -TERM "${pid}" >/dev/null 2>&1 || true
  done
  sleep 1
  for pid in ${pids}; do
    kill -KILL "${pid}" >/dev/null 2>&1 || true
  done
  return 0
}

ensure_tcp_port_free_or_prompt() {
  # Loops until port is free, or user cancels. Prints the chosen port.
  local port="$1"
  local purpose="$2"

  while is_tcp_port_listening "${port}"; do
    local out choice
    out="$(ss_listen_tcp "${port}")"
    choice="$(menu "${APP}" "پورت ${port} برای ${purpose} مشغول است.\n\n${out}\n\nچه کار کنیم؟" \
      "1" "Stop paqet service (اگر خودش گرفته)" \
      "2" "Kill process(es) on this port" \
      "3" "Choose a different port" \
      "0" "Cancel")" || return 1

    case "${choice}" in
      1)
        systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
        ;;
      2)
        kill_port_pids "${port}" || true
        ;;
      3)
        port="$(input "${APP}" "پورت جدید برای ${purpose}:" "${port}")" || return 1
        ;;
      0)
        return 1
        ;;
    esac
  done

  printf "%s" "${port}"
}

ensure_tcp_port_free_or_prompt_simple() {
  # Same as ensure_tcp_port_free_or_prompt, but does NOT offer changing ports.
  # This keeps the "simple setup" flow portless for the user.
  local port="$1"
  local purpose="$2"

  while is_tcp_port_listening "${port}"; do
    local out choice
    out="$(ss_listen_tcp "${port}")"
    choice="$(menu "${APP}" "پورت ${port} برای ${purpose} مشغول است.\n\n${out}\n\nچه کار کنیم؟" \
      "1" "Stop paqet service (اگر خودش گرفته)" \
      "2" "Kill process(es) on this port" \
      "0" "Cancel")" || return 1

    case "${choice}" in
      1)
        systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
        ;;
      2)
        kill_port_pids "${port}" || true
        ;;
      0)
        return 1
        ;;
    esac
  done

  printf "%s" "${port}"
}

ensure_service_can_reconfigure() {
  # If service is active, ask user to stop or cancel.
  if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
    if yesno "${APP}" "سرویس ${SERVICE_NAME} الان فعاله. برای ستاپ جدید باید متوقف بشه.\n\nStop کنیم؟"; then
      systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
    else
      return 1
    fi
  fi
  return 0
}

detect_default_iface() {
  ip route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="dev") {print $(i+1); exit}}'
}

detect_local_ipv4() {
  local iface="$1"
  ip -4 -o addr show dev "${iface}" scope global 2>/dev/null | awk '{print $4}' | head -n1 | cut -d/ -f1
}

detect_gateway_ipv4() {
  ip -4 route show default 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if($i=="via") {print $(i+1); exit}}'
}

detect_gateway_mac() {
  local gw="$1" iface="$2"
  ip neigh show "${gw}" dev "${iface}" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="lladdr") {print $(i+1); exit}}'
}

ensure_gateway_mac() {
  local gw="$1" iface="$2"
  local mac
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  ping -c 1 -W 1 "${gw}" >/dev/null 2>&1 || true
  mac="$(detect_gateway_mac "${gw}" "${iface}")"
  if [[ -n "${mac}" ]]; then
    printf "%s" "${mac}"
    return 0
  fi
  return 1
}

write_sysctl_defaults() {
  cat >"${SYSCTL_CONF}" <<'EOF'
# paqet baseline tuning (adjust per host/RAM/NIC)
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.core.rmem_default = 8388608
net.core.wmem_default = 8388608
net.core.netdev_max_backlog = 250000
EOF
  sysctl --system >/dev/null 2>&1 || true
}

install_service() {
  mkdir -p "${CONFIG_DIR}" "${LIB_DIR}"

  if [[ ! -x "${IPTABLES_SH}" ]]; then
    msg "iptables helper not found at ${IPTABLES_SH}. Re-install scripts."
    return 1
  fi
  if [[ ! -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    msg "systemd iptables helper not found at ${IPTABLES_SYSTEMD_SH}. Re-install scripts."
    return 1
  fi

  cat >"${SERVICE_FILE}" <<EOF
[Unit]
Description=paqet tunnel
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStartPre=${IPTABLES_SYSTEMD_SH} apply ${CONFIG_FILE}
ExecStart=${BIN} run -c ${CONFIG_FILE}
ExecStopPost=${IPTABLES_SYSTEMD_SH} remove ${CONFIG_FILE}
Restart=on-failure
RestartSec=1
LimitNOFILE=1048576

# Hardening (keep compatible with raw sockets)
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${SERVICE_NAME}" >/dev/null 2>&1 || true
}

start_service() {
  systemctl restart "${SERVICE_NAME}"
}

status_screen() {
  local out
  out="$(SYSTEMD_COLORS=0 systemctl status "${SERVICE_NAME}" --no-pager --full --plain 2>&1 || true)"
  if [[ -z "${out}" ]]; then
    out="(empty output)\n\nTry: systemctl status ${SERVICE_NAME}"
  fi
  printf "%b\n" "${out}" | textbox "${APP} status" 22 78
}

set_forward_single_rule() {
  # Replace the entire top-level "forward:" block with a single TCP rule.
  # This keeps the setup predictable and avoids duplicate YAML keys.
  local listen_addr="$1" target_addr="$2"
  local tmp
  tmp="$(mktemp)"

  awk '
    BEGIN { in_fwd=0 }
    # Start of forward block
    /^[[:space:]]*forward:[[:space:]]*$/ { in_fwd=1; next }
    # End of forward block when next top-level key starts (non-indented)
    in_fwd && /^[^[:space:]][^:]*:/ { in_fwd=0 }
    # Print lines when not inside forward block
    !in_fwd { print $0 }
  ' "${CONFIG_FILE}" >"${tmp}"

  cat >>"${tmp}" <<EOF

forward:
  - listen: "${listen_addr}"
    target: "${target_addr}"
    protocol: "tcp"
EOF

  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}" || true
}

uninstall_all() {
  if ! yesno "${APP}" "این کار سرویس و فایل‌های paqet را پاک می‌کند (اما باینری‌ها را نگه می‌دارد). ادامه؟"; then
    return 0
  fi

  # Stop service first (ExecStopPost may remove iptables rules).
  systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true

  # Best-effort: remove server-side iptables rules explicitly.
  if [[ -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    "${IPTABLES_SYSTEMD_SH}" remove "${CONFIG_FILE}" || true
  fi

  systemctl disable "${SERVICE_NAME}" >/dev/null 2>&1 || true
  rm -f "${SERVICE_FILE}"
  systemctl daemon-reload >/dev/null 2>&1 || true

  rm -rf "${CONFIG_DIR}"
  rm -f "${SYSCTL_CONF}"
  sysctl --system >/dev/null 2>&1 || true

  msg "Uninstall completed. (Binary remains: ${BIN})"
}

purge_all() {
  if ! yesno "${APP}" "این کار حذف کامل انجام می‌دهد: سرویس، کانفیگ، sysctl، iptables rules و باینری‌ها. ادامه؟"; then
    return 0
  fi

  systemctl stop "${SERVICE_NAME}" >/dev/null 2>&1 || true
  if [[ -x "${IPTABLES_SYSTEMD_SH}" ]]; then
    "${IPTABLES_SYSTEMD_SH}" remove "${CONFIG_FILE}" || true
  fi
  systemctl disable "${SERVICE_NAME}" >/dev/null 2>&1 || true

  rm -f "${SERVICE_FILE}" || true
  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl reset-failed "${SERVICE_NAME}" >/dev/null 2>&1 || true

  rm -rf "${CONFIG_DIR}" || true
  rm -f "${SYSCTL_CONF}" || true
  sysctl --system >/dev/null 2>&1 || true

  # Remove binaries + scripts
  rm -f "${BIN}" /usr/local/bin/paqet-ui || true
  rm -rf "${LIB_DIR}" || true

  msg "Purge completed."
}

gen_server_config() {
  local iface="$1" ip="$2" router_mac="$3" port="$4" key="$5"
  local key_q
  key_q="$(yaml_quote "${key}")"
  cat >"${CONFIG_FILE}" <<EOF
role: "server"

log:
  level: "warn"

listen:
  addr: ":${port}"

network:
  interface: "${iface}"
  ipv4:
    addr: "${ip}:${port}"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 33554432
    snaplen: ${PCAP_SNAPLEN}
    promisc: ${PCAP_PROMISC}
    immediate: ${PCAP_IMMEDIATE}
    timeout_ms: ${PCAP_TIMEOUT_MS}

transport:
  protocol: "kcp"
  conn: 1
  kcp:
    mode: "${KCP_MODE}"
    mtu: ${KCP_MTU}
    rcvwnd: 32768
    sndwnd: 32768
    block: "aes"
    key: ${key_q}
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    max_sessions: 2048
    max_streams_total: 262144
    max_streams_per_session: 32768
    header_timeout: 10
    smuxbuf: 16777216
    streambuf: 4194304
EOF
}

gen_client_config_no_socks() {
  # X-UI only mode: do not generate a SOCKS listener at all.
  local iface="$1" ip="$2" router_mac="$3" local_port="$4" remote_ip="$5" port="$6" key="$7" conn="$8"
  local key_q
  key_q="$(yaml_quote "${key}")"
  if ! [[ "${conn}" =~ ^[0-9]+$ ]] || (( conn < 1 )); then
    conn=1
  fi
  if (( conn > 256 )); then
    conn=256
  fi
  cat >"${CONFIG_FILE}" <<EOF
role: "client"

log:
  level: "warn"

network:
  interface: "${iface}"
  ipv4:
    addr: "${ip}:${local_port}"
    router_mac: "${router_mac}"
  pcap:
    sockbuf: 33554432
    snaplen: ${PCAP_SNAPLEN}
    promisc: ${PCAP_PROMISC}
    immediate: ${PCAP_IMMEDIATE}
    timeout_ms: ${PCAP_TIMEOUT_MS}

server:
  addr: "${remote_ip}:${port}"

transport:
  protocol: "kcp"
  conn: ${conn}
  kcp:
    mode: "${KCP_MODE}"
    mtu: ${KCP_MTU}
    rcvwnd: 32768
    sndwnd: 32768
    block: "aes"
    key: ${key_q}
    guard: true
    guard_magic: "PQT1"
    guard_window: 30
    guard_skew: 1
    header_timeout: 10
    smuxbuf: 16777216
    streambuf: 4194304
EOF
}

setup_outside_server() {
  local iface ip gw mac port key
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  # Simple defaults (no port prompts unless busy)
  port="9999"
  port="$(ensure_tcp_port_free_or_prompt_simple "${port}" "Tunnel port (server)" )" || return 1

  key="$("${BIN}" secret)"

  mkdir -p "${CONFIG_DIR}"
  gen_server_config "${iface}" "${ip}" "${mac}" "${port}" "${key}"
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  msg "سرور خارج ستاپ شد.\n\nکلید Pairing (این را به سرور داخل بده):\n${key}\n\nStatus از منو قابل مشاهده است."
}

setup_inside_xui_only() {
  # One-step inside setup for X-UI only (no SOCKS, no extra ports):
  # Listens on 0.0.0.0:<public_port> and forwards via tunnel to outside 127.0.0.1:2443.
  local iface ip gw mac remote key public_port xray_port listen_addr target_addr local_port conn local_end
  ensure_service_can_reconfigure || return 1
  iface="$(detect_default_iface || true)"
  if [[ -z "${iface}" ]]; then
    msg "نتونستم اینترفیس پیش‌فرض رو پیدا کنم."
    return 1
  fi
  ip="$(detect_local_ipv4 "${iface}" || true)"
  if [[ -z "${ip}" ]]; then
    msg "نتونستم IPv4 روی ${iface} پیدا کنم."
    return 1
  fi
  gw="$(detect_gateway_ipv4 || true)"
  if [[ -z "${gw}" ]]; then
    msg "نتونستم gateway پیش‌فرض رو پیدا کنم."
    return 1
  fi
  mac="$(ensure_gateway_mac "${gw}" "${iface}" || true)"
  if [[ -z "${mac}" ]]; then
    msg "نتونستم MAC روتر (gateway) رو پیدا کنم. لطفاً gateway رو ping کنید و دوباره تلاش کنید."
    return 1
  fi

  remote="$(input "${APP}" "IP سرور خارج؟ (مثال: 1.2.3.4)" "")" || return 1
  port="9999"
  key="$(password "${APP}" "کلید Pairing که روی سرور خارج نمایش داده شد را وارد کن")" || return 1

  public_port="443"
  public_port="$(ensure_tcp_port_free_or_prompt "${public_port}" "X-UI entrypoint (inside)" )" || return 1

  xray_port="2443"
  listen_addr="0.0.0.0:${public_port}"
  target_addr="127.0.0.1:${xray_port}"

  conn="$(pick_client_conn)"
  local_port="$(pick_client_raw_port_range "${conn}")"
  local_end=$(( local_port + conn - 1 ))

  mkdir -p "${CONFIG_DIR}"
  gen_client_config_no_socks "${iface}" "${ip}" "${mac}" "${local_port}" "${remote}" "${port}" "${key}" "${conn}"
  set_forward_single_rule "${listen_addr}" "${target_addr}"
  chmod 600 "${CONFIG_FILE}"

  write_sysctl_defaults
  install_service
  start_service

  msg "سرور داخل برای X-UI ستاپ شد.\n\nForward:\n  ${listen_addr}  ->  ${target_addr}\n\nTransport:\n  kcp sessions: ${conn}\n  client raw port range: ${local_port}-${local_end}\n\nروی سرور خارج در x-ui inbound بساز:\n  VLESS / TCP\n  listen: 127.0.0.1\n  port:   ${xray_port}\n\nبعد روی کلاینت‌ها:\n  address = IP ایران\n  port    = ${public_port}"
}

main_loop() {
  while true; do
    local choice
    choice="$(menu "${APP}" "یک گزینه را انتخاب کن:" \
      "1" "ستاپ سرور خارج (Server)" \
      "15" "Setup inside (X-UI only, one-step, no SOCKS)" \
      "3" "Status" \
      "6" "Stop service" \
      "7" "Uninstall (keep binaries)" \
      "13" "Purge (remove everything)" \
      "0" "Exit")" || exit 0

    case "${choice}" in
      1) setup_outside_server ;;
      15) setup_inside_xui_only ;;
      3) status_screen ;;
      6) systemctl stop "${SERVICE_NAME}" || true ;;
      7) uninstall_all ;;
      13) purge_all ;;
      0) exit 0 ;;
    esac
  done
}

need_root "$@"
ensure_deps
main_loop
